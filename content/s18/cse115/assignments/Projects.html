---
title: Projects
short_title: hw
next_content_short: none
previous_content_short: lab
---


== Project Submissions


<p>
    For all of the projects, and later labs, you will be submitting you entire eclipse project as a .jar (Java Archive)
    file instead of submitting a single .java file. This is necessary when submitting a project with code in multiple
    files.
</p>

<p>
    To create a .jar file in Eclipse:
</p>

<ol>
    <li>
        In the left sidebar, right click on your project and select "export"
    </li>
    <li>
        In the export wizard window, choose "JAR file" from he "Java" folder and click next
    </li>
    <li>
        On the next screen, make sure the following boxes are checked
        <ul>
            <li>"Export generated class and files and resources"</li>
            <li>"Export Java source files and resources"</li>
            <li>"Compress the contents of the JAR file"</li>
            <li>"Add directory entries"</li>
        </ul>
    </li>
    <li>
        Make sure the correct project is selected, choose a location to save your file, then click finish to create the
        .jar file containing your entire project
    </li>
    <li>
        Submit this .jar file to AutoLab
    </li>
</ol>

<p>
    You may submit as many times as you'd like until the deadline. Only your last submission will be counted towards
    your grade. If your score decreases while you are working on a new objective you can always resubmit your previous
    jar file to get your completed objective back.
</p>

<p>
    You progress on the progress objectives will not be reflected on the course website. Your project scores will only
    be shown in AutoLab as this page is only for information.
</p>

<p>
    <strong>All Projects are Due: Friday, May 18th @ 11:59 pm</strong>
</p>

<p>
    * There will be no support from the course staff during finals week
</p>


== Ratings

<h4>
    Background
</h4>

<p>
    Rating systems are all around us. Whether we are shopping online, looking for a place to eat, or deciding which
    movie
    to see many of us will search for other people's opinions before we decide how to spend our time and money. In
    this assignment we will explore different aspects of ratings while building our own system where we
    can share and analyze preferences.
</p>

<p>
    By the end of this project we will analyzing ratings of song that have been made by this class of CSE115 student.
    Add your ratings using this the form below and you will compute the top rated songs in the class by objective 5.
</p>


<br/>
<hr/>
<h4>Rate Songs</h4><br/>

<p>
    Use this form to rate songs find the classes favorite songs. Aggregate results will appear here:
    <a href="https://fury.cse.buffalo.edu/api/musicRatings/getAllSongs">https://fury.cse.buffalo.edu/api/musicRatings/getAllSongs</a>
</p>

<p>
    Each rated song must be linked to a YouTube video by providing the id for the video. This id is an 11 digit String
    that is unique for each video and can be found in the url
    of the video. See <a href="https://docs.joeworkman.net/rapidweaver/stacks/youtube/video-id">here</a> for an example.
</p>

<p>
    * You must be logged in to rate songs
</p>

<div class="card">
    <div class="card-body">
        <form action="/api/musicRatings/rateSong" method="post">

            <div>
                <label>YouTube ID (11 digit id from url):</label>
                <input type="text" name="youtube_id"/>
            </div>
            <br/>
            <div>
                <label>Your Rating:</label>&nbsp;
                <input type="radio" name="rating" value="1"> 1 &nbsp;&nbsp;
                <input type="radio" name="rating" value="2"> 2&nbsp;&nbsp;
                <input type="radio" name="rating" value="3"> 3&nbsp;&nbsp;
                <input type="radio" name="rating" value="4"> 4&nbsp;&nbsp;
                <input type="radio" name="rating" value="5"> 5
            </div>
            <br/>
            <label>* Artist and Title are only required if the song is not yet in the API</label><br/>
            <div>
                <label>Artist:</label>
                <input type="text" name="artist"/>
            </div>

            <div>
                <label>Title:</label>
                <input type="text" name="title"/>
            </div>

            <div>
                <input type="submit" value="Rate Song"/>
            </div>

        </form>
    </div>
</div>

<br/>
<hr/>
<h4>
    Objective 1: Bayesian Average
</h4>
<br/>
<p>
    Your first objective in this project is to compute the Bayesian average for a given list of ratings. The Bayesian
    average is computed by adding a fixed number of extra ratings at a certain value to the existing ratings.
</p>

<h5>Background</h5>
<p>
    By
    comparing items based on their Bayesian average, as opposed to directly using the average of all review scores, we
    can improve the usefulness of these comparisons. For example, in a 5 star rating system an item with 1 rating of 5
    stars will be ranked higher than an item with 200 ratings at an average rating of 4.9. Most
    likely we would prefer the later item since we can be more confident that it is a highly rated item since there are
    200 opinions being considered. To address this we can rank the items by their
    Bayesian rating and choose 5 extra ratings of 3 stars to be added to each item. Now the
    first item has 1 rating of 5 and 5 ratings of 3 for a Bayesian average of 3.33 and the
    second item has 200 ratings at an average of 4.9 and 5 ratings of 3 for a Bayesian
    average of 4.85. Bayesian averages can be used in this way to lower ratings where
    there is not enough information to make a judgment on the item.
</p>

<h5>Tasks</h5>

<p>
    Setup the structure for this project and write a method to compute the Bayesian average of a list of ratings.
</p>

<ol>
    <li>Create a new project in Eclipse that will contain you work for all 5 objectives</li>
    <li>Create a new package in the src folder named "ratings"</li>
    <li>In the ratings package, create a new class named "Main" and write a main method in this class. This class
        will be the entry point for the project and will be the only class with a main method. You should use this class
        to test your project
    </li>
    <li>Create a class named "RatingsAnalyzer" in the ratings package. In this new class, write a public static
        method named "bayesianAverage" that takes three parameters (an ArrayList of Doubles, an int, then a double) and
        returns a double. The first parameter represents all the ratings for a particular item, the second parameter is
        the
        number of additional ratings to add, and the third parameter is the value of these additional ratings. The
        return
        value is the bayesian average of these ratings based on these parameters.
    </li>
</ol>

<div class="alert alert-info">
    <b>Submit your project on AutoLab following the instructions at the top of this page.</b> For each of the 3 project
    you can submit on AutoLab an unlimited number of times and only the score of your latest submission will be counted
    for your grade. You are strongly encouraged to submit often to receive feedback on your progress. You should always
    verify through AutoLab that you have completed an objective before moving on to the next objective
</div>

<br/>
<hr/>
<h4>
    Objective 2: Find the Best Song
</h4>

<p>
    Now that we can compute the Bayesian average of a list of ratings we can start computing ratings.
    The first ratings that we'll compute will be of songs. For this objective you will be given a csv file with song
    ratings and you'll compute the song with the highest Bayesian average.
</p>


<a href="/static/data/sample_songs.csv">sample_songs.csv</a><br/>
<a href="/static/data/large_songs.csv">large_songs.csv</a><br/>

<h5>Tasks</h5>

<p>
    Create a Song class, create Song instances based on data read from a file, and compute the Song with the highest
    Bayesian average.
</p>

<ol>
    <li>Create a package named "ratables" inside the ratings package. In the newly created ratables package, create a
        class named "Song" containing the following methods. Note that none of these methods are static since they will
        belong
        to
        instances of the Song class and not the class itself:
        <ol type="i">
            <li>
                A public constructor taking three Strings as parameters in the order (youTubeID, artist, title). These
                values must be stored in instance variables of your choosing
            </li>
            <li>
                A public method named "getID" that takes no parameters and returns the youTubeID that was provided when
                the constructor was called as a String
            </li>
            <li>
                A public method named "getLink" that takes no parameters and return the YouTube url for this song as a
                String. The url must be in the format "https://www.youtube.com/watch?v=###########" with ###########
                replaced with the youTubeID for this song
            </li>
            <li>
                A public method named "getDescription" that takes no parameters and returns a String containing the
                artist and title provided
                when the constructor was called. The format of this description must be "artist - title", as in the
                artist of the song then the title of the song separated by the String " - "
            </li>
            <li>
                A public method named "addRating" that takes a double as a parameter and returns void. The double
                represents a rating made for this song which must be stored in an instance variable. Note that this
                method will be called each time a new rating in found for the same song and all ratings must be stored
                in an instance variable
            </li>
            <li>
                A public method named "getRatings" that takes no parameters and returns an ArrayList of Doubles
                containing every rating that was added to this song with the addRating method
            </li>
            <li>[optional] You may add any other methods or instance variables that will help you complete the project
                objectives. For example, it is helpful to override the toString method so you can print out songs
                while testing your program to verify the output
            </li>
        </ol>
    </li>
    <li>
        Create a new class in the ratings package named "DataSources" that will contains methods that read data into our
        program. In this class write a public static method named "readSongCSVFile"
        that takes one String as a parameter and returns an ArrayList of Songs. The input parameter is the name of a
        csv file containing song ratings where each line is in the format "YouTubeID,artist,title,rating"
        This method will return all the data in this file in an ArrayList of Songs.
        Note that songs can be rated multiple times in the file and each rating must be recorded in the same Song
        object that represents that song. (Hint: The YouTubeIDs are unique and can be used to identify a song and can
        stored in a data structure to check if you've seen a song multiple times. For each line that is read from the
        file, check if the YouTubeID from the line is already in your data structure. If it is, the rating needs to be
        added to the existing Song instead of creating a new Song object. One way to do this is by using a HashMap
        of YouTubeIDs (Strings) to Song objects)
    </li>
    <li>
        In the RatingsAnalyzer class write a public static method named "bestSong" that takes three parameters (an
        ArrayList of Songs,
        an int, and a double) and returns a Song. The method will return the Song from the parameter ArrayList with the
        highest Bayesian average. The int and double parameters are the number of extra reviews and the value of those
        reviews to be used while computing the Bayesian averages (You should call your method from objective 1 to
        compute these Bayesian averages)
    </li>
</ol>


<br/>
<hr/>
<h4>
    Objective 3: Abstraction and Products
</h4>

<p>
    So far our program can find the best song by bayesian average, but what if we want to rate more than just songs?
    In this objective we will refactor our code so it can also be used for Amazon.com products. To do this we will
    create an abstract class that will be extended by both Song and Product classes. With this structure we can easily
    expand our program to rate anything we'd like by writing another class that extends our abstract class and
    implements its methods.
</p>

<a href="/static/data/sample_products.csv">sample_products.csv</a><br/>
<a href="/static/data/large_products.csv">large_products.csv</a><br/>

<p>
    Amazon data provided by:<br/>
    Ups and downs: Modeling the visual evolution of fashion trends with one-class collaborative filtering
    R. He, J. McAuley
    WWW, 2016
    <br/>
    <br/>
    Image-based recommendations on styles and substitutes
    J. McAuley, C. Targett, J. Shi, A. van den Hengel
    SIGIR, 2015
</p>

<h5>Tasks</h5>
<ol>
    <li>In the ratables package create an abstract class named "Ratable" containing the following. Note that none of
        these methods are static:
        <ol type="i">
            <li>
                A public default constructor (take no parameters). This constructor will be implicitly called whenever
                an extending classes constructor is called. You can use this constructor to initialize and instance
                variables that are needed by all sub-classes (ex. An ArrayList of Doubles storing all the ratings)
            </li>
            <li>
                A public abstract method named "getID" that takes no parameters and returns a String. This method will
                be used to return a unique id for any type of Ratable
            </li>
            <li>
                A public abstract method named "getLink" that takes no parameters and returns a String. This method will
                be used to return a url for any type of Ratable
            </li>
            <li>
                A public abstract method named "getDescription" that takes no parameters and returns a String. This
                method will be used to a description for any type of Ratable
            </li>
            <li>
                A public method named "addRating" that takes a double as a parameter and returns void. The double
                represents a rating made for this ratable which must be stored in an instance variable. Note this method
                is identical to the one from the Song class. The method is being moved from Song to Ratable
            </li>
            <li>
                A public method named "getRatings" that takes no parameters and returns an ArrayList of Doubles
                containing every rating that was added to this ratable with the addRating method. Note this method
                is identical to the one from the Song class. The method is being moved from Song to Ratable
            </li>
            <li>
                [optional] You may add any other methods or instance variables that will help you complete the project
                objectives. For example, it is helpful to override the toString method so you can print out ratables
                while testing your program to verify the output
            </li>
        </ol>
    </li>
    <li>Modify the Song class to extend the Ratable abstract class
        <ol type="i">
            <li>Extend Ratable from Song using the extends keyword</li>
            <li>Remove the addRating and getRatings methods from the Song class. Since Song now extends Ratable, and
                Ratable defines these methods, each Song will inherit these methods from the Ratable class
            </li>
            <li>Note that since we already defined the three abstract methods from the Ratable class in the Song class
                there is no more work needed to extend Ratable from Song. However, depending on your previous
                implementation you may have to make a few more changes as needed (ex. Remove a line where you create a
                new ArrayList for the ratings)
            </li>
        </ol>
    </li>

    <li>In the ratables package create a class named "Product" that extends Ratable and containing the following:
        <ol type="i">
            <li>
                A public constructor that takes 1 String as a parameter. This string represents the asin (Amazon
                Standard
                Identification Number) of the product and it should be stored in an instance variable
            </li>
            <li>
                Implement the getID method to return the asin that was provided in the constructor call
            </li>
            <li>
                Implement the getLink method to return a link to the product page for this product. The format of this
                url
                must be "https://www.amazon.com/dp/##########" where ########## is the asin for this product
            </li>
            <li>
                Implement the getDescription method to return the asin for this product. Note that this is the same as
                the
                getID method
            </li>
            <li>
                Now that we've implemented the 3 abstract methods we have completed this class
            </li>
        </ol>
    </li>
    <li>
        Now that we've refactored the our ratables to be either songs or products we will need to write methods in the
        rest of our program that will handle and ratables. To start, whenever we read data from a source we will return
        the data as Ratables instead of Songs or Products. For this task, write a public static method in the
        DataSources class
        named "readSongsAsRatables" that takes a String as a parameter and returns an ArrayList of Ratables. This method
        will read a csv file with Song ratings in the same format as in the readSongCSVFile method. The only difference
        is the return type which is an ArrayList of Ratables instead of an ArrayList of Songs. (Hint: you can call
        readSongCSVFile from this method and add all the Songs into a new ArrayList of Ratables)
    </li>
    <li>
        Write a public static method in the DataSources class named "readProductCSVFile" that takes a String as a
        parameter and
        returns an ArrayList of Ratables. The input String is the name of a csv file where each line is in the format
        "asin,reviewerName,rating,review" and the output is an ArrayList of Ratables containing all the product ratings
        from this file.
    </li>
    <li>
        In the RatingsAnalyzer class write a public static method named "bestRatable" that takes three parameters (an
        ArrayList of
        Ratable,
        an int, and a double) and returns a Ratable. The method will return the Ratable from the parameter ArrayList
        with the
        highest Bayesian average. The int and double parameters are the number of extra reviews and the value of those
        reviews to be used while computing the Bayesian averages. Note that this method can be used for Songs or
        Products.
    </li>
</ol>


<br/>
<hr/>
<h4>
    Objective 4: Top k Lists
</h4>
<p>
    We have a lot of structure in place for our project are we have the flexibility to write code that can be used for
    Songs, Products, and any other class that we add as long as it extends Ratable. For this objective we now want to
    analyze the ratings beyond just finding the Ratable with highest Bayesian average.
</p>

<h5>Tasks</h5>

<ol>
    <li>Write three Comparator classes for Ratables
        <ol type="i">
            <li>In the ratings package create a new package named "comparators"</li>
            <li>In the comparators package create a new class named AlphabeticalComparator that implements the
                Comparator of
                Ratable interface. Implement the compare method to order the ratables alphabetically, ignoring case,
                according to their descriptions (Use the getDescription method)
            </li>
            <li>In the comparators package create a new class named NumberOfRatingsComparator that implements the
                Comparator of
                Ratable interface. Implement the compare method to order the ratables by the number of reviews for each
                ratable in decreasing order
            </li>
            <li>In the comparators package create a new class named BayesianAverageComparator that implements the
                Comparator of
                Ratable interface. Implement the compare method to order the ratables by their bayesian average in
                decreasing order. For this class you will need a constructor that takes an int and a double as
                parameters
                representing the number of extra ratings and the value of these ratings and store these values in
                instance
                variables so they can be used in the compare method
            </li>
        </ol>
    </li>
    <li>In the RatingsAnalyzer class write a public static method named "getTopK" an ArrayList of Ratables, an int (k),
        and a
        Comparator of Ratables as
        parameters and returns an ArrayList of Ratables. This method returns the top k ratables from the ArrayList based
        on the provided Comparator. This method
        must return the list in order such that the first element is the first ratable according to the provided
        Comparator. Ties can be broken arbitrarily
    </li>
</ol>

<p>
    While testing you top k method you should write code in your Main class that calls a method from your DataSources
    class to get an ArrayList of Ratables and call getTopK with this ArrayList.
</p>

<br/>
<hr/>
<h4>
    Objective 5: The Internet
</h4>

<p>
    So far we've been reading data from csv files that are saved on our hard drive. Our next objective to access song
    data that is hosted on the Internet through a web API and use the data in our program. This will allow us to work
    with real-time data that is constantly updating
</p>

<h5>Task</h5>

<ol>
    <li>Write a public static method in the DataSources class named "getSongsFromAPI" that takes no parameters and
        returns an
        ArrayList of Ratables. This method will access the API endpoint at the url
        "https://fury.cse.buffalo.edu/api/musicRatings/getAllSongs"
        which will return a JSON array where each element in the array is a JSON object in the format
        {"title":"No Regrets", "artist":"Aesop Rock", "ratings":[5,5,4,5], "youtubeID":"sClhmDN5Fcs"}. The method will
        return all the data given by the API in an ArrayList of Ratables
    </li>
</ol>


<br/>
<hr/>
<h4>
    Debriefing
</h4>

<p>
    Congratulations! You have written a complete project that analyzes ratings of
    songs and Amazon products. This program has the flexibility to read songs from a file, products from a file, or
    songs from a web API and generate top k lists based on their bayesian averages, number of ratings, or
    alphabetically. By this point you should see that this project can be expanded to rate more types of ratables from
    other sources or by different criteria without adding much additional code. By using object-oriented principles
    we are able to reuse significant amounts of code even if our goals change significantly. For example, we used the
    same exact code to add/store ratings, compare ratable, and generate top k lists based on any of three different
    criteria whether we were analyzing Amazon product reviews from a csv file or song ratings from a web API.
</p>


<!--Start Rhymes-->

== Rhymes

<h4>
    Background
</h4>

<p>
    Let's make a game! For this project we will develop the game pictured below. In this game the user will be given
    a reference word and can choose from 4 other words. One of the four choices will rhyme with the given word and
    the other three will not. The player's goal is to choose the rhyming word.
</p>

<img src="/static/rhymes1.png" class="img-fluid"/>
<br/><br/>

<p>
    Once the user selects one of the choices they will earn 1 point if their choice was the rhyming word or lose 1
    point if their choice did not rhyme with the given word. In either case the user will see a new set of words.
</p>

<img src="/static/rhymes2.png" class="img-fluid"/>
<br/><br/>
<p>
    For the purposes of this game we will say two words rhyme if the last syllable of each word is the same. A more
    formal
    definition is given below.
</p>

<br/>
<hr/>
<h4>
    Data
</h4>

<p>
    Download: <a href="/static/data/rhymingDictionary.txt">rhymingDictionary.txt</a><br/>
    Source: <a href="http://www.speech.cs.cmu.edu/cgi-bin/cmudict">http://www.speech.cs.cmu.edu/cgi-bin/cmudict</a>
</p>
<p>
    To determine if two words rhyme we will first need a way of finding the pronunciation of words. For this purpose we
    will use the dictionary given above where rhymingDictionary.txt is a subset of the CMU pronunciation dictionary
    that can be found at the source link. This subset of words were chosen to work well with this project and is
    suitable for playing this game (ie. Only common words and every word rhymes with at least 1 other word in the file).
    Please visit the source for documentation and the full dictionary download if you would like to use more than the
    provided words for other projects.
</p>

<br/>
<hr/>
<h4>
    Defining a Rhyme
</h4>

<p>
    The pronunciation dictionary provides the sounds for each word and each sound has a type. For the types we are only
    concerned if the sound is a vowel or not. All vowel sounds end with an integer that determines the stress given to
    that vowel and other sounds do not have this stress so a vowel can be identified by checking if a sound ends with an
    integer. We will say that two words rhyme if all the sounds from the last vowel and after are the same. Words
    will rhyme even if the last vowel sounds have different stress. By defining a rhyme in this way we effectively
    consider
    two words to rhyme if their last syllable have the same sound, ignoring stress. For example all the following words
    from the
    dictionary will be considered rhymes since the last vowel is the same and all sounds after the last vowel are the
    same:
</p>

<p>
    HALF &nbsp;HH AE1 F<br/>
    PHOTOGRAPH &nbsp;F OW1 T AH0 G R AE2 F<br/>
    STAFF &nbsp;S T AE1 F<br/>
    LAUGH &nbsp;L AE1 F<br/>
</p>
<p>
    These words also all rhyme with each other:
</p>
<p>
    THOUSAND &nbsp;TH AW1 Z AH0 N D<br/>
    DIAMOND &nbsp;D AY1 M AH0 N D<br/>
    FUND &nbsp;F AH1 N D<br/>
    AND &nbsp;AH0 N D<br/>
    SECOND &nbsp;S EH1 K AH0 N D<br/>
    ISLAND &nbsp;AY1 L AH0 N D<br/>
    LEGEND &nbsp;L EH1 JH AH0 N D<br/>
</p>

<br/>
<hr/>
<h4>
    Objective 1: GUI Layout
</h4>

<p>
    Before we start implementing the details of the game we will first setup the gui so we have a convenient way to see
    the later features we will add to the project.
</p>

<!--* Objective 1: Setup Testing-->
<!-- -Write Main-->
<!-- -setup GUI and GameModel headers so Main compiles-->
<!-- -GUI has component on the correct panels. Advise that the components should be stored in instance variables since they need to change throughout the game [can return empty JPanels]-->
<!-- -Recommend to get the GUI looking like it did in the example add x panel to NORTH, etc-->
<!-- -At the end of this objective they should see something that looks like the game, but with no text-->


<h5>Tasks</h5>

<ol>
    <li>Create a new project in Eclipse</li>
    <li>Create a new package in the src folder named "rhymes"</li>
    <li>
        In the rhymes package, create a new class named "GameModel" with a public constructor that takes a String as a
        parameter. The body of the constructor can be empty for now. We will add methods and instance variables to
        this class in later objectives
    </li>
    <li>
        In the rhymes package, create a new class named "GUI" with a public constructor that takes an instance of the
        GameModel class as a parameter. In this class write the following three methods that return JPanels. (Hint:
        Some of the components on these panels, and the GameModel instance from the constructor, will need to be
        stored in instance variables and initialized in the
        constructor to complete later objectives. Planning ahead can save you time later)
        <ol type="i">
            <li>
                A public method named "getWordPanel" that takes no parameters and returns a JPanel. This JPanel will
                contain a single JLabel. In later objectives this label will contain the word given to the player.
                (In the example images this is the NORTH panel on the JFrame)
            </li>
            <li>
                A public method named "getChoicesPanel" that takes no parameters and returns a JPanel. This JPanel will
                contain 4 JButtons with any text, for now. In later objectives these buttons will contain the choices
                provided for the player. (In the example images this is the CENTER panel on the JFrame)
            </li>
            <li>
                A public method named "getScorePanel" that takes no parameters and returns a JPanel. This JPanel will
                contain a single JLabel with the text "Score:". In later objectives this label will contain the current
                score of the player.
                (In the example images this is the SOUTH panel on the JFrame)
            </li>
        </ol>
    </li>
    <li>
        In the rhymes package, create a new class named "Main" and write a main method in this class. This class
        will be the only one with a main method or a JFrame. Do not add a JFrame anywhere else in your project. In this
        class you can test and play your game by setting up a JFrame in the same way we've been using in the class
        and adding the three GUI panels to the locations given above. You will need to create new GameModel and GUI
        instances to setup this JFrame. JFrame in images has size 500x140
    </li>
</ol>


<!--/**-->
<!--* Objective 1: Setup Testing-->
<!-- -Write Main-->
<!-- -setup GUI and GameModel headers so Main compiles-->
<!-- -GUI has component on the correct panels. Advise that the components should be stored in instance variables since they need to change throughout the game [can return empty JPanels]-->
<!-- -Recommend to get the GUI looking like it did in the example add x panel to NORTH, etc-->
<!-- -At the end of this objective they should see something that looks like the game, but with no text-->


<br/>
<hr/>
<h4>
    Objective 2: Rhyming Dictionary
</h4>

<p>
    Since rhyming is a core feature of this game we will need a way to determine whether or not two words rhyme.
    For this objective we will write a method that will accomplish this by using the rhyming dictionary provided
    in the data section above.
</p>


<h5>Tasks</h5>


<ol>
    <li>
        In the rhymes package, create another package named "dictionary" and in this new package create a class named
        "RhymingDictionary" with the following
        <ol type="i">
            <li>
                A public constructor that takes a String as a parameter. This String will be interpreted as the filename
                for a rhyming dictionary in the same format as the one given in the data section of this project
                (ie. rhymingDictionary.txt). In this format each line contains the word, then two spaces, then each
                sound in that word separated by single spaces. All this data should be stored in an instance variable(s)
                so it can be used in the other methods of this class (Hint: while parsing this file you can call .split
                on each
                line with " &nbsp;" and " " as parameters instead of "," as we did while parsing csv files)
            </li>
            <li>
                A public method named "isRhyme" that takes two Strings as parameters and returns a boolean. This method
                returns true if the two input Strings rhyme according to the definition given above. It will return
                false if the words do not rhyme, or if either word is not in the dictionary. The case of the letters in
                the input words should be ignored
            </li>
        </ol>

    </li>

</ol>

<!--Objective 2: Parse Dictionary + isRhyme-->
<!-- -Create RhymingDictionary in dictionary package-->
<!-- -Write constructor that parses the file-->
<!-- -isRhyme-->

<br/>
<hr/>
<h4>
    Objective 3: Random Words
</h4>

<p>
    Now that we can determine if two words rhyme we can start writing methods that will interact with our game.
    For this objective you will write methods to get random words to give to the player and generate the 4 random
    choices.
</p>

<h5>Tasks</h5>
<ul>
    <li>
        In the RhymingDictionary class, write a public method named "randomWord" that takes no parameters and returns a
        String. This method will return a random word that is in the rhyming dictionary. You may use any approach to get
        a random word as long as each word in the dictionary has [close to] an equal probability of being returned.
        Recall from Lab 8 that one approach is to call Collections.shuffle on an ArrayList of Strings containing all the
        words in the dictionary then returning the word at index 0
    </li>
    <li>
        In the RhymingDictionary class, write a public method named "getChoices" that takes a String as a parameter and
        returns an ArrayList of Strings. The returned ArrayList will contain the 4 choices that will be given to the
        player of the game. Of the four choices, exactly 1 of them will rhyme with the reference word (the input of
        this method is the reference word. The rhyming word cannot be the reference word) and the other 3 will not
        rhyme. All these words will be randomly chosen so the user will have
        different choices even if they see the same reference word multiple times. The position of the correct choice
        must also be randomized (ie. If the correct answer is always on the left-most button the game is trivial.
        Similarly, a
        multiple choice exam where every answer is "c" can be easy). (Hint: Create two ArrayLists, one with all words
        that
        rhyme with the input and another with all words that don't rhyme with the input and call Collections.shuffle
        on both to get random choices in the way as we used with the randomWord method. Add the four words to ArrayList
        that you will return, then call Collections.shuffle on these choices before returning them)
    </li>
</ul>


<!--Objective 3: Random Words-->
<!-- -randomWord-->
<!-- -getChoices-->


<br/>
<hr/>
<h4>
    Objective 4: The Game Model
</h4>
<p>
    Your next objective is to implement the logic of the game and initialize the gui for the first round of the game.
    After this objective is complete the gui should look like the gui from the images and will have appropriate choices
    and a
    reference word given to the user. You have already written a lot of this functionality in the RhymingDictionary
    class which will be used to complete this objective.
</p>

<h5>Tasks</h5>

<ol>
    <li>
        Implement the existing GameModel class with the following functionality: (Note that after implementing this
        class
        the logic of the game is fully functional and is ready to be played if it is connected to a user interface. By
        keeping the code for the game separate from the user interface we can easily reuse this game with a different
        interface. For example, we can use this same game model as a web game by writing a web interface
        for the game)
        <ol type="i">
            <li>
                Implement the existing constructor to interpret the input String as the filename for a rhyming
                dictionary file that will be used for this instance of the game and initialize the game by setting the
                player's score to 0 and generating the first reference word and the 4 choices
            </li>
            <li>
                A public method named "makeChoice" that takes a String as a parameter and has return type void. This
                method will interpret the input as a guess made by the player and update the state of the game
                according to the rules of the game given in the background section
            </li>
            <li>
                A public method named "getScore" that takes no parameters and returns the player's current score as an
                int
            </li>
            <li>
                A public method named "getGivenWord" that takes no parameters and returns the reference word that
                is given to the player as a String
            </li>
            <li>
                A public method named "getChoices" that takes no parameters and returns the 4 choices that are given to
                the player as an ArrayList of Strings
            </li>
        </ol>
    </li>
    <li>Now connect the logic of the game to the gui that we wrote in objective 1. We will do this by implementing
        the following:
        <ol type="i">
            <li>
                When the GUI constructor is called, set the text of the 2 labels and 4 buttons to the appropriate values
                from
                the GameModel instance that is the parameter of the constructor
            </li>
            <li>
                Write a public method named "update" that takes no parameters and has return type void. This method will
                update the text of the 2 labels and 4 buttons to the appropriate values from
                the GameModel instance. This method will be called whenever the GameModel instance changes state so the
                most current information is displayed to the user
            </li>
        </ol>

    </li>
</ol>


<!--Objective 4: GameModel-->
<!-- -GameModel class-->
<!-- -GUI initialization so the first round of the game is visible in the GUI-->


<br/>
<hr/>
<h4>
    Objective 5: Game Controller
</h4>

<p>
    At this point you have all the logic needed for the game and a complete gui for the user to interact with the game,
    however we're missing a way for the model and the gui to interact with each other. We will write one final class
    that will control this interaction and connect all of our code together to complete the game (If you are interested
    in learning more about this approach to software design it is formally defined as Model-View-Controller, or
    <a href="https://en.wikipedia.org/wiki/Model–view–controller">MVC</a>)
</p>

<h5>Tasks</h5>

<ol>
    <li>
        In the rhymes package, write a new class named AnswerListener that implements the MouseListener interface.
        This class will connect the rest of our code together and instances of it will be attached to the choice buttons
        on
        the gui so they can react to the user. In this class implement:
        <ol type="i">
            <li>
                A public constructor that takes a JButton, a GameModel, and a GUI as parameters in that order and
                stores these in instance variables. These instances will give this controller access to both the model
                and the gui, as well as a reference to the button to which this instance is attached
            </li>
            <li>
                Change the foreground color of the button to BLUE when the mouse enters the button, BLACK when the mouse
                exits the button, WHITE when the mouse is pressed on the button, and BLUE when the mouse
                is released on the button. This color changing will make our game more responsive to the user
            </li>
            <li>
                When the mouse is released on the button, make a guess using the text on that button then update
                the gui
            </li>
        </ol>
    </li>
    <li>
        Attach a new instance of AnswerListener to each of the buttons on the gui. Run Main and verify that your game
        is fully functional
    </li>
</ol>


<br/>
<hr/>
<h4>
    Debriefing
</h4>

<p>
    You just wrote a whole game with quite a few pieces. More than that, you have a good amount of code that be
    easily reused in other coding projects for other ideas that you may have. For example, if you want to write a
    program where
    knowing how to pronounce words is important you can reuse your RhymingDictionary class and save a lot of time. You
    may
    want to add more methods to this class, but you won't be rewriting all the code to parse the dictionary file and
    find the sounds for a given word. Or if you want to write a program to help you write lyrics that rhyme you
    can use this class to generate a list of all words that rhyme with a given word and list of every possible
    word that you can choose from. In this case you should download the full dictionary from the reference link.
</p>

<p>
    Whether you reuse this code or not, as you progress through your career in software development you should always
    keep in mind that by separating the functionality in your program you can save a lot of time later by reusing that
    code. This also has the benefit that your code will be easier to test and maintain. For example, if we want to
    change the definition of a rhyme to require all syllables to rhyme or to require that the stress on the last vowel
    has to match we only have to make that change in the isRhyme method. One change in the code and the entire game will
    be different. We could even implement multiple definitions and let the user choose which one to use through the gui.
    Or maybe we want this game to use alliterations instead of rhyme. No problem. Just change a few lines in one
    method, and maybe rename it to isAlliteration instead of isRhyme for clarity. Maybe we want to give the user 6
    options instead of 4. Add 2 more buttons and have getChoices return 2
    more wrong answers and we're done updating (as long as you used loops whenever working with these components).
    Not only are these changes easy to make, it's also easy to find the code where these changes should be made
    (Compared
    to writing the entire project in one file. Or much worse, one method). By
    thinking through the design of our software we can save a significant amount of time later.
</p>
<p>Or as Dr. Hertz
    puts it: <b>"hours of coding makes up for minutes of planning"</b></p>
</p>


== Maps

<div class="alert alert-info">
    Project description in progress. There may be minor edits and rewrites until this notice is removed
</div>

<h4>
    Background
</h4>

<p>
    Whether it's a location-based phone app, an embedded GPS device, or a web service with geographically specific
    offerings, as a software developer it's likely that you will be working with
    geolocation at some point in your career. This project will provide an introduction to this world (pun intended.
    Come at me bro).
</p>

<img src="/static/maps1.png" class="img-fluid"/>
<br/><br/>

<p>
    This image shows the final software that you will create. This will have functionality such a user can type into
    the search bar which will populate the dropdown box with every city matching the search, sorted by population.
    Clicking the button will take the user to that city. The user can also click on the map to navigate the area
    surrounding the city.
</p>

<p>
    Before we start implementing this functionality, let's explore 2 data sources that we will use to realize this
    project.
</p>

<br/>
<hr/>
<h4>
    City Data
</h4>

<p>
    Download: <a href="/static/data/cities.csv">cities.csv</a><br/>
    This project includes GeoLite data created by MaxMind, available from <a href="http://www.maxmind.com">http://www.maxmind.com</a>
</p>
<p>
    In this project we will be taking advantage of city location and population data from MaxMind. This file provides
    location and population data for thousands of cities from hundreds of countries. The cities.csv file
    that can be downloaded above is the exact file that will used while testing your project in AutoLab. This file
    contains a subset of the data set that has been modified to be suitable for this
    project (Contains only cities with population data; accent names removed; header line removed) in the csv format
    "Country,City,Region,Population,Latitude,Longitude". Please visit the source
    website for more information about this data as well as a download of the unmodified data set.
</p>


<br/>
<hr/>
<h4>
    Map Tile API
</h4>

<p>
    Documentation: <a href="http://wiki.openstreetmap.org/wiki/Slippy_map_tilenames">http://wiki.openstreetmap.org/wiki/Slippy_map_tilenames</a><br/>
    API root: "http://a.tile.openstreetmap.org/"
    Sample usage: <a href="http://a.tile.openstreetmap.org/6/17/23.png">https://a.tile.openstreetmap.org/6/17/23.png</a>
</p>

<p>
    To get map images in our program we will use the freely available open street map tile server. This API will serve
    us partial images of the world map which we call tiles. A specific tile is requested by specifying the x and y
    locations as well as the zoom level of the desired tile where x and y is computed using a Mercator projection.
    Review the documentation for more details about requesting tiles and computing the projection. Note that the site
    provides example code that you cannot use. Since you did not write this code, and it's not provided
    by the course, using it is not allowed. You can however use these examples as a reference and implement them in
    your own way with your own code.
</p>


<br/>
<hr/>
<h4>
    Objective 1: GUI Setup
</h4>

<p>
    As with the rhymes project, we will begin by setting up the layout for the project. In fact, the structure of the
    project is similar to the rhymes project throughout the 5 objectives.
</p>


<h5>Tasks</h5>

<ol>
    <li>Create a new project in Eclipse</li>
    <li>Create a new package in the src folder named "maps"</li>
    <li>In the maps package, create a new package named "cities"</li>
    <li>
        In the cities package, create a new class named "Cities" with a public constructor that takes a String as a
        parameter. The body of the constructor can be empty for now. We will add methods and instance variables to
        this class in later objectives
    </li>
    <li>
        In the maps package, create a new class named "MapGUI" with a public constructor that takes an instance of the
        Cities class as a parameter. In this class write the following two methods that return JPanels (Hint: Many of
        the components on this gui will need to be accessed in other methods later. Initializing them in the constructor
        and storing them in instance variables now can save time later)
        <ol type="i">
            <li>
                A public method named "getSearchPanel" that takes no parameters and returns a JPanel. This JPanel will
                contain a single JLabel. In later objectives this label will contain the word given to the player.
                (In the example image this is the NORTH panel on the JFrame)
            </li>
            <li>
                A public method named "getMapPanel" that takes no parameters and returns a JPanel. This method will
                contain 9 JLabels in 3x3 grid where each JLabel will eventually contain a map tile image. For now, do
                not add anything to these JLabels. To get the JLabels to
                line be organized properly we will use a different layout manager for this panel. We will use the
                GridLayout with 3 rows and 3 columns which can be achieved with the code
                "panel.setLayout(new GridLayout(3, 3));" assuming your panel is stored in a variable named panel. With
                this layout components will be added to the panel in a 3x3 grid in row major order starting with the
                upper left (same order as reading a page). For example, the first 3 elements added to this panel will be
                placed in the first row, then the next 3 elements will be added to the second row. (In the example
                images this is the CENTER panel on the JFrame)
            </li>
        </ol>
    </li>
    <li>
        In the maps package, create a new class named "Main" and write a main method in this class. This class
        will be the only one with a main method or a JFrame. Do not add a JFrame anywhere else in your project. In this
        class you can test and play your game by setting up a JFrame in the same way we've been using in the class
        and adding the two GUI panels to the locations given above. You will need to create new Cities and MapGUI
        instances to setup this JFrame. JFrame was sized by calling frame.pack();
    </li>
</ol>

<!--Objective 1: Project Setup-->
<!-- -Create Main, MapGUI, Cities-->
<!-- -Implement MapGUI with-->
<!-- -—Constructor that initializes everything (you will add to this throughout the project)-->
<!-- -—getSearchPanel with a textField, comboBox, and button-->
<!-- -—getMapPanel with 9 labels in a 3x3 grid layout (hint: store these as an ArrayList of JLabel. You cannot add different labels later. You will call setIcon on these labels with the appropriate map tiles)-->


<br/>
<hr/>
<h4>
    Objective 2: Cities
</h4>

<p>
    For this objective we will read the cities data and store it in a data structure. We will also write several methods
    that will be called to add city functionality to the program.
</p>


<h5>Tasks</h5>

<ol>
    <li>
        In the cities package, create a new class named "City" and implement the following:
        <ol type="i">
            <li>
                Override the toString method to return the data of the city in the format
                "[population] - [name], [region], [country]". For example, Buffalo, NY would be printed as
                "279557 - buffalo, NY, us"
            </li>
            <li>
                Implement anything else in this class that you will need to complete the project. You will want to
                include a constructor and getter methods, though you are free to design these methods however you would
                like
            </li>
        </ol>
    </li>
    <li>
        In the cities package, implement the existing "Cities" class to store all the cities data by writing:
        <ol type="i">
            <li>
                A public constructor that takes a String as a parameter. This String will be the filename of the
                cities.csv file (including the directory path) and the constructor will parse this file and store
                the data in an instance variable(s) (hint: An ArrayList of type City can store all this data)
            </li>
            <li>
                A public method named "getDefaultCity" that takes no parameters and returns an instance of a City. The
                returned City will represent Buffalo, NY which will be used to initialize the map on our GUI. For this
                method, find Buffalo, NY in the stored cities and return it
            </li>
            <li>
                A public method named "searchByName" that takes a String as a parameter and returns an ArrayList of
                type City. The input String should be interpreted as the search criteria provided by the user. This
                method will return an ArrayList of every City with a name that contains the input String, sorted by
                decreasing population. For example, if the input is "york" this method will return
                ["8107916 - new york, NY, us", "144202 - york, Q5, gb", "46010 - west new york, NJ, us", "39587 - york,
                PA, us", "15172 - yorkton, 11, ca", "3101 - hevizgyork, 16, hu", "2020 - vamosgyork, 11, hu"]
                in this order
            </li>
        </ol>

    </li>
</ol>


<!--Objective 2: Cities-->
<!-- -(everything in the cities package)-->
<!-- -Create City class with constructor and all the getters (toString standardized. The rest can be different)-->
<!-- -read the cities file-->
<!-- -getDefaultCity to return buffalo, NY-->
<!-- -search by substring and sort results by population-->


<br/>
<hr/>
<h4>
    Objective 3: Map Tiles
</h4>

<p>
    In this objective you will write the code that will connect to the tile server API and retrieve the correct tiles
    for a given city so we can display the map for that city.
</p>

<p>
    Note: For all tiles in this project we will use a zoom level of 6 and the user will not be able to change the zoom
    level.
    Since you will need this value throughout the project, and you may want to change it during testing or after you
    complete all 5 objective and want change your software, you should store the zoom level in a variable in a single
    class. This can be done by creating a static variable so it can be accessed in every class without instantiating the
    class where it is defined (Example: This is how constants like Math.PI, Math.E, and Integer.MAX_VALUE are defined)

</p>

<h5>Tasks</h5>
<ul>
    <li>In the maps package, create a new package named "tiles"</li>
    <li>
        In the tiles package, create a new class named "Tile" which will represent a single map tile that can be
        requested from the API. You may implement whatever methods, constructors, and instance variables you need to
        represent a map tile through instances of this class as long the following methods are implemented:
        <ol type="i">
            <li>
                A public method named "getTileURL" that takes no parameters and returns a String. This String will be
                url for the API that will retrieve the map tile represented by this instance of the TIle class at a zoom
                level of 6. Be sure to use the API at the server "http://a.tile.openstreetmap.org/" (note the "http",
                not
                "https", since this String must match exactly as expected in AutoLab you cannot be off by a single
                character)
            </li>
            <li>
                A public method named "getImageIcon" that takes no parameters and returns an ImageIcon. This method will
                return a new ImageIcon for the url returned by the getTileURL method. Review the JLabel lecture notes
                for an example (you will add these ImageIcons to JLabels in a later objective)
            </li>
        </ol>
    </li>
    <li>
        In the tiles package, create a new class named "TileUtils" which will contain several static methods that will
        create the appropriate tiles for our maps. You will use this class as a library of static methods in the rest of
        your project. Since this class does not rely on any state that is stored in instance variables we will make the
        methods static and call them through the class instead of instantiating the class, similar to how we use the
        methods in the Math class. In this class, implement the following:
        <ol type="i">
            <li>
                A public static method named "getTile" that takes a City as a parameter and returns a Tile. This method
                will return a new Tile representing the map tile containing the input City at zoom level 6 (Hint: This
                will involve projecting latitude/longitude onto x/y values in the Mercator projection)
            </li>
            <li>
                A public static method named "getTileMap" that takes a Tile as a parameter and returns an ArrayList of
                Tiles. The returned ArrayList will contain the 9 map tiles for a 3x3 map with the input tile at the
                center. The tiles in the ArrayList should be in row-major order as described in objective 1. This
                implies that the input tile will be index 4 in the returned ArrayList (In this project you will not have
                to address tile wrapping and will not be tested with inputs where this would be required, though you
                should think about what would happen if the input tile is adjacent to the prime meridian or either of
                the
                poles. In these cases your x or y value would need to wrap around the tile set to get the geographically
                adjacent tiles. For example, if the reference tile has a x value of 0 you could not simply subtract 1 to
                get the tile directly to the west)
            </li>
        </ol>
    </li>
</ul>


<!--Objective 3: Tiles-->
<!-- -(everything in the tiles package)-->
<!-- -Tile-->
<!-- -—getTileURL-->
<!-- -—getImageIcon-->
<!-- -TileUtils-->
<!-- -—getTile(City city)-->
<!-- -—ArrayList<Tile> getTileMap(Tile tile) in row major order-->
<!-- -Note that you do not have to handle wrapping, but think about it-->


<br/>
<hr/>
<h4>
    Objective 4: Search Cities
</h4>

<p>
    Now that you written code that can utilize both the cities data and the map tiles API we are ready to combine these
    into a user feature on the GUI. By the end of this object a user will be able to search for a city by name, be given
    a list of results, and select one to be shown on the map.
</p>

<h5>Tasks</h5>

<ol>
    <li>
        In the MapGUI class write a public method named "setReferenceTile" that takes a Tile as a parameter and has
        return type void. Calling this method will update the GUI to display a map with the input reference tile as
        the center tile. By calling the tile methods you've written in the previous objective you can write this method
        with only a few lines of code. Recall that you will add the ImageIcons of each tile to it's corresponding JLabel
        by calling setIcon from each JLabel. Do not add new JLabels to the GUI, but add new Icons to the existing
        JLabels (Hint: It is recommended that you add a println each time you get an image icon. Since this method will
        require 9 API calls it will run rather slow. The print statements will provide a way for you to see whether or
        not your program is still making API calls)
    </li>
    <li>
        When a new instance of MapGUI is created, initialize the map to show Buffalo, NY. This can be accomplished by
        calling getDefaultCity, getTile, and setReferenceTile without adding any additional code. After this task you
        should be able to run your Main method and see a map of Western New York
    </li>
    <li>
        You may also need to add other methods, including getter methods for some components, to your MapGUI class to
        achieve the rest of the functionality in this project. You can add any other methods you would like to this and
        other classes
    </li>
    <li>
        In the maps package, create a new package named "control". This package will contain all the Listeners that will
        control the interactions between the GUI and the cities/tile functionality. This is commonly referred to as glue
        code and follows the same MVC approach as the rhymes project
    </li>
    <!--<li>-->
        <!--In the tiles package, create a new class named "Tile" which will represent a single map tile that can be-->
        <!--requested from the API. You may implement whatever methods, constructors, and instance variables you need to-->
        <!--represent a map tile through instances of this class as long the following methods are implemented:-->
        <!--<ol type="i">-->
            <!--<li>-->
                <!--A public method named "getTileURL" that takes no parameters and returns a String. This String will be-->
                <!--url for the API that will retrieve the map tile represented by this instance of the TIle class at a zoom-->
                <!--level of 6. Be sure to use the API at the server "http://a.tile.openstreetmap.org/" (note the "http",-->
                <!--not-->
                <!--"https", since this String must match exactly as expected in AutoLab you cannot be off by a single-->
                <!--character)-->
            <!--</li>-->
            <!--<li>-->
                <!--A public method named "getImageIcon" that takes no parameters and returns an ImageIcon. This method will-->
                <!--return a new ImageIcon for the url returned by the getTileURL method. Review the JLabel lecture notes-->
                <!--for an example (you will add these ImageIcons to JLabels in a later objective)-->
            <!--</li>-->
        <!--</ol>-->
    <!--</li>-->
</ol>

<!--Objective 4: Search Feature-->
<!-- -setReferenceTile-->
<!-- -—sets up the map tiles and adds them to the gui-->
<!-- -—Default to adding tiles for Buffalo at startup (you can do this by calling this from init with getDefaultCity -->

<!-- -SearchListener implements KeyListener-->
<!-- -—takes gui and cities-->
<!-- -—on release of any key, updates the dropdown with searchByName of the search term (hint: might want helper methods in gui to get and pass the info needed. We arn’t doing individual components in these listeners anymore)-->
<!-- -—add instance to the text field-->

<!-- -CitySelectListener implements ActionListener-->
<!-- -—Takes a gui-->
<!-- -—sets the reference tile to the selected tile-->
<!-- -—add instance to the go button-->


<br/>
<hr/>
<h4>
    Objective 5: Movement with Mouse
</h4>

<!--<p>-->

<!--</p>-->

<!--<h5>Tasks</h5>-->

<!--<ol>-->
<!--<li></li>-->
<!--</ol>-->

<!--Objective 5: Movement with Mouse-->
<!-- -TranslateListener implements MouseListener-->
<!-- -—TranslateListener(MapGUI gui, int dx, int dy)-->
<!-- -—on mouse press, move the reference tile-->
<!-- -—Add instance to each JLabel with the appropriate dx, dy-->

<br/>
<hr/>
<h4>
    Debriefing
</h4>

<!--<p>-->
<!--This works, but some functionality is very slow. Stay tuned for CSE116 and beyond where you will learn how to write-->
<!--efficient programs that will fix these issues.-->

<!--We have 9 calls to the Internet. This takes just as long as clicking refresh on a page 9 times and waiting for it-->
<!--to fully load after each click. This is slow, but it can be a lot faster by making all 9 calls at the same time.-->
<!--For this we will need more tools than we have now.-->

<!--We can make the search for cities faster as well. We get away with that because we don't have very many cities. If-->
<!--we had a data set with 100's of millions of items we would need to be more concerned with the efficiency of our-->
<!--data structure.-->
<!--</p>-->