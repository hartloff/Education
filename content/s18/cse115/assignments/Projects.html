---
title: Projects
short_title: hw
next_content_short: none
previous_content_short: lab
---


== Project Submissions


<p>
    For all of the projects, and later labs, you will be submitting you entire eclipse project as a .jar (Java Archive)
    file instead of submitting a single .java file. This is necessary when submitting a project with code in multiple
    files.
</p>

<p>
    To create a .jar file in Eclipse:
</p>

<ol>
    <li>
        In the left sidebar, right click on your project and select "export"
    </li>
    <li>
        In the export wizard window, choose "JAR file" from he "Java" folder and click next
    </li>
    <li>
        On the next screen, make sure the following boxes are checked
        <ul>
            <li>"Export generated class and files and resources"</li>
            <li>"Export Java source files and resources"</li>
            <li>"Compress the contents of the JAR file"</li>
            <li>"Add directory entries"</li>
        </ul>
    </li>
    <li>
        Make sure the correct project is selected, choose a location to save your file, then click finish to create the
        .jar file containing your entire project
    </li>
    <li>
        Submit this .jar file to AutoLab
    </li>
</ol>

<p>
    You may submit as many times as you'd like until the deadline. Only your last submission will be counted towards
    your grade. If your score decreases while you are working on a new objective you can always resubmit your previous
    jar file to get your completed objective back.
</p>

<p>
    You progress on the progress objectives will not be reflected on the course website. Your project scores will only
    be shown in AutoLab as this page is only for information.
</p>

<p>
    <strong>All Projects are Due: Friday, May 18th @ 11:59 pm</strong>
</p>

<p>
    * There will be no support from the course staff during finals week
</p>


== Ratings

<h4>
    Background
</h4>

<p>
    Rating systems are all around us. Whether we are shopping online, looking for a place to eat, or deciding which
    movie
    to see many of us will search for other people's opinions before we decide how to spend our time and money. In
    this assignment we will explore different aspects of ratings while building our own system where we
    can share and analyze preferences.
</p>

<p>
    By the end of this project we will analyzing ratings of song that have been made by this class of CSE115 student.
    Add your ratings using this the form below and you will compute the top rated songs in the class by objective 5.
</p>


<br/>
<hr/>
<h4>Rate Songs</h4><br/>

<p>
    Use this form to rate songs find the classes favorite songs. Aggregate results will appear here:
    <a href="https://fury.cse.buffalo.edu/api/musicRatings/getAllSongs">https://fury.cse.buffalo.edu/api/musicRatings/getAllSongs</a>
</p>

<p>
    Each rated song must be linked to a YouTube video by providing the id for the video. This id is an 11 digit String
    that is unique for each video and can be found in the url
    of the video. See <a href="https://docs.joeworkman.net/rapidweaver/stacks/youtube/video-id">here</a> for an example.
</p>

<p>
    * You must be logged in to rate songs
</p>

<div class="card">
    <div class="card-body">
        <form action="/api/musicRatings/rateSong" method="post">

            <div>
                <label>YouTube ID (11 digit id from url):</label>
                <input type="text" name="youtube_id"/>
            </div>
            <br/>
            <div>
                <label>Your Rating:</label>&nbsp;
                <input type="radio" name="rating" value="1"> 1 &nbsp;&nbsp;
                <input type="radio" name="rating" value="2"> 2&nbsp;&nbsp;
                <input type="radio" name="rating" value="3"> 3&nbsp;&nbsp;
                <input type="radio" name="rating" value="4"> 4&nbsp;&nbsp;
                <input type="radio" name="rating" value="5"> 5
            </div>
            <br/>
            <label>* Artist and Title are only required if the song is not yet in the API</label><br/>
            <div>
                <label>Artist:</label>
                <input type="text" name="artist"/>
            </div>

            <div>
                <label>Title:</label>
                <input type="text" name="title"/>
            </div>

            <div>
                <input type="submit" value="Rate Song"/>
            </div>

        </form>
    </div>
</div>

<br/>
<hr/>
<h4>
    Objective 1: Bayesian Average
</h4>
<br/>
<p>
    Your first objective in this project is to compute the Bayesian average for a given list of ratings. The Bayesian
    average is computed by adding a fixed number of extra ratings at a certain value to the existing ratings.
</p>

<h5>Background</h5>
<p>
    By
    comparing items based on their Bayesian average, as opposed to directly using the average of all review scores, we
    can improve the usefulness of these comparisons. For example, in a 5 star rating system an item with 1 rating of 5
    stars will be ranked higher than an item with 200 ratings at an average rating of 4.9. Most
    likely we would prefer the later item since we can be more confident that it is a highly rated item since there are
    200 opinions being considered. To address this we can rank the items by their
    Bayesian rating and choose 5 extra ratings of 3 stars to be added to each item. Now the
    first item has 1 rating of 5 and 5 ratings of 3 for a Bayesian average of 3.33 and the
    second item has 200 ratings at an average of 4.9 and 5 ratings of 3 for a Bayesian
    average of 4.85. Bayesian averages can be used in this way to lower ratings where
    there is not enough information to make a judgment on the item.
</p>

<h5>Tasks</h5>

<p>
    Setup the structure for this project and write a method to compute the Bayesian average of a list of ratings.
</p>

<ol>
    <li>Create a new project in Eclipse that will contain you work for all 5 objectives</li>
    <li>Create a new package in the src folder named "ratings"</li>
    <li>In the ratings package, create a new class named "Main" and write a main method in this class. This class
        will be the entry point for the project and will be the only class with a main method. You should use this class
        to test your project
    </li>
    <li>Create a class named "RatingsAnalyzer" in the ratings package. In this new class, write a public static
        method named "bayesianAverage" that takes three parameters (an ArrayList of Doubles, an int, then a double) and
        returns a double. The first parameter represents all the ratings for a particular item, the second parameter is
        the
        number of additional ratings to add, and the third parameter is the value of these additional ratings. The
        return
        value is the bayesian average of these ratings based on these parameters.
    </li>
</ol>


<br/>
<hr/>
<h4>
    Objective 2: Find the Best Song
</h4>

<p>
    Now that we can compute the Bayesian average of a list of ratings we can start computing ratings.
    The first ratings that we'll compute will be of songs. For this objective you will be given a csv file with song
    ratings and you'll compute the song with the highest Bayesian average.
</p>


<a href="/static/data/sample_songs.csv">sample_songs.csv</a><br/>
<a href="/static/data/large_songs.csv">large_songs.csv</a><br/>

<h5>Tasks</h5>

<p>
    Create a Song class, create Song instances based on data read from a file, and compute the Song with the highest
    Bayesian average.
</p>

<ol>
    <li>Create a package named "ratables" inside the ratings package. In the newly created ratables package, create a
        class named "Song" containing the following methods. Note that none of these methods are static since they will
        belong
        to
        instances of the Song class and not the class itself:
        <ol type="i">
            <li>
                A public constructor taking three Strings as parameters in the order (youTubeID, artist, title). These
                values must be stored in instance variables of your choosing
            </li>
            <li>
                A public method named "getID" that takes no parameters and returns the youTubeID that was provided when
                the constructor was called as a String
            </li>
            <li>
                A public method named "getLink" that takes no parameters and return the YouTube url for this song as a
                String. The url must be in the format "https://www.youtube.com/watch?v=###########" with ###########
                replaced with the youTubeID for this song
            </li>
            <li>
                A public method named "getDescription" that takes no parameters and returns a String containing the
                artist and title provided
                when the constructor was called. The format of this description must be "artist - title", as in the
                artist of the song then the title of the song separated by the String " - "
            </li>
            <li>
                A public method named "addRating" that takes a double as a parameter and returns void. The double
                represents a rating made for this song which must be stored in an instance variable. Note that this
                method will be called each time a new rating in found for the same song and all ratings must be stored
                in an instance variable
            </li>
            <li>
                A public method named "getRatings" that takes no parameters and returns an ArrayList of Doubles
                containing every rating that was added to this song with the addRating method
            </li>
            <li>[optional] You may add any other methods or instance variables that will help you complete the project
                objectives. For example, it is helpful to override the toString method so you can print out songs
                while testing your program to verify the output
            </li>
        </ol>
    </li>
    <li>
        Create a new class in the ratings package named "DataSources" that will contains methods that read data into our
        program. In this class write a public static method named "readSongCSVFile"
        that takes one String as a parameter and returns an ArrayList of Songs. The input parameter is the name of a
        csv file containing song ratings where each line is in the format "YouTubeID,artist,title,rating"
        This method will return all the data in this file in an ArrayList of Songs.
        Note that songs can be rated multiple times in the file and each rating must be recorded in the same Song
        object that represents that song. (Hint: The YouTubeIDs are unique and can be used to identify a song and can
        stored in a data structure to check if you've seen a song multiple times. For each line that is read from the
        file, check if the YouTubeID from the line is already in your data structure. If it is, the rating needs to be
        added to the existing Song instead of creating a new Song object. One way to do this is by using a HashMap
        of YouTubeIDs (Strings) to Song objects)
    </li>
    <li>
        In the RatingsAnalyzer class write a public static method named "bestSong" that takes three parameters (an
        ArrayList of Songs,
        an int, and a double) and returns a Song. The method will return the Song from the parameter ArrayList with the
        highest Bayesian average. The int and double parameters are the number of extra reviews and the value of those
        reviews to be used while computing the Bayesian averages (You should call your method from objective 1 to
        compute these Bayesian averages)
    </li>
</ol>


<br/>
<hr/>
<h4>
    Objective 3: Abstraction and Products
</h4>

<p>
    So far our program can find the best song by bayesian average, but what if we want to rate more than just songs?
    In this objective we will refactor our code so it can also be used for Amazon.com products. To do this we will
    create an abstract class that will be extended by both Song and Product classes. With this structure we can easily
    expand our program to rate anything we'd like by writing another class that extends our abstract class and
    implements its methods.
</p>

<a href="/static/data/sample_products.csv">sample_products.csv</a><br/>
<a href="/static/data/large_products.csv">large_products.csv</a><br/>

<p>
    Amazon data provided by:<br/>
    Ups and downs: Modeling the visual evolution of fashion trends with one-class collaborative filtering
    R. He, J. McAuley
    WWW, 2016
    <br/>
    <br/>
    Image-based recommendations on styles and substitutes
    J. McAuley, C. Targett, J. Shi, A. van den Hengel
    SIGIR, 2015
</p>

<h5>Tasks</h5>
<ol>
    <li>In the ratables package create an abstract class named "Ratable" containing the following. Note that none of
        these methods are static:
        <ol type="i">
            <li>
                A public default constructor (take no parameters). This constructor will be implicitly called whenever
                an extending classes constructor is called. You can use this constructor to initialize and instance
                variables that are needed by all sub-classes (ex. An ArrayList of Doubles storing all the ratings)
            </li>
            <li>
                A public abstract method named "getID" that takes no parameters and returns a String. This method will
                be used to return a unique id for any type of Ratable
            </li>
            <li>
                A public abstract method named "getLink" that takes no parameters and returns a String. This method will
                be used to return a url for any type of Ratable
            </li>
            <li>
                A public abstract method named "getDescription" that takes no parameters and returns a String. This
                method will be used to a description for any type of Ratable
            </li>
            <li>
                A public method named "addRating" that takes a double as a parameter and returns void. The double
                represents a rating made for this ratable which must be stored in an instance variable. Note this method
                is identical to the one from the Song class. The method is being moved from Song to Ratable
            </li>
            <li>
                A public method named "getRatings" that takes no parameters and returns an ArrayList of Doubles
                containing every rating that was added to this ratable with the addRating method. Note this method
                is identical to the one from the Song class. The method is being moved from Song to Ratable
            </li>
            <li>
                [optional] You may add any other methods or instance variables that will help you complete the project
                objectives. For example, it is helpful to override the toString method so you can print out ratables
                while testing your program to verify the output
            </li>
        </ol>
    </li>
    <li>Modify the Song class to extend the Ratable abstract class
        <ol type="i">
            <li>Extend Ratable from Song using the extends keyword</li>
            <li>Remove the addRating and getRatings methods from the Song class. Since Song now extends Ratable, and
                Ratable defines these methods, each Song will inherit these methods from the Ratable class
            </li>
            <li>Note that since we already defined the three abstract methods from the Ratable class in the Song class
                there is no more work needed to extend Ratable from Song. However, depending on your previous
                implementation you may have to make a few more changes as needed (ex. Remove a line where you create a
                new ArrayList for the ratings)
            </li>
        </ol>
    </li>

    <li>In the ratables package create a class named "Product" that extends Ratable and containing the following:
        <ol type="i">
            <li>
                A public constructor that takes 1 String as a parameter. This string represents the asin (Amazon
                Standard
                Identification Number) of the product and it should be stored in an instance variable
            </li>
            <li>
                Implement the getID method to return the asin that was provided in the constructor call
            </li>
            <li>
                Implement the getLink method to return a link to the product page for this product. The format of this
                url
                must be "https://www.amazon.com/dp/##########" where ########## is the asin for this product
            </li>
            <li>
                Implement the getDescription method to return the asin for this product. Note that this is the same as
                the
                getID method
            </li>
            <li>
                Now that we've implemented the 3 abstract methods we have completed this class
            </li>
        </ol>
    </li>
    <li>
        Now that we've refactored the our ratables to be either songs or products we will need to write methods in the
        rest of our program that will handle and ratables. To start, whenever we read data from a source we will return
        the data as Ratables instead of Songs or Products. For this task, write a public static method in the
        DataSources class
        named "readSongsAsRatables" that takes a String as a parameter and returns an ArrayList of Ratables. This method
        will read a csv file with Song ratings in the same format as in the readSongCSVFile method. The only difference
        is the return type which is an ArrayList of Ratables instead of an ArrayList of Songs. (Hint: you can call
        readSongCSVFile from this method and add all the Songs into a new ArrayList of Ratables)
    </li>
    <li>
        Write a public static method in the DataSources class named "readProductCSVFile" that takes a String as a
        parameter and
        returns an ArrayList of Ratables. The input String is the name of a csv file where each line is in the format
        "asin,reviewerName,rating,review" and the output is an ArrayList of Ratables containing all the product ratings
        from this file.
    </li>
    <li>
        In the RatingsAnalyzer class write a public static method named "bestRatable" that takes three parameters (an
        ArrayList of
        Ratable,
        an int, and a double) and returns a Ratable. The method will return the Ratable from the parameter ArrayList
        with the
        highest Bayesian average. The int and double parameters are the number of extra reviews and the value of those
        reviews to be used while computing the Bayesian averages. Note that this method can be used for Songs or
        Products.
    </li>
</ol>


<br/>
<hr/>
<h4>
    Objective 4: Top k Lists
</h4>
<p>
    We have a lot of structure in place for our project are we have the flexibility to write code that can be used for
    Songs, Products, and any other class that we add as long as it extends Ratable. For this objective we now want to
    analyze the ratings beyond just finding the Ratable with highest Bayesian average.
</p>

<h5>Tasks</h5>

<ol>
    <li>Write three Comparator classes for Ratables
        <ol type="i">
            <li>In the ratings package create a new package named "comparators"</li>
            <li>In the comparators package create a new class named AlphabeticalComparator that implements the
                Comparator of
                Ratable interface. Implement the compare method to order the ratables alphabetically, ignoring case,
                according to their descriptions (Use the getDescription method)
            </li>
            <li>In the comparators package create a new class named NumberOfRatingsComparator that implements the
                Comparator of
                Ratable interface. Implement the compare method to order the ratables by the number of reviews for each
                ratable in decreasing order
            </li>
            <li>In the comparators package create a new class named BayesianAverageComparator that implements the
                Comparator of
                Ratable interface. Implement the compare method to order the ratables by their bayesian average in
                decreasing order. For this class you will need a constructor that takes an int and a double as
                parameters
                representing the number of extra ratings and the value of these ratings and store these values in
                instance
                variables so they can be used in the compare method
            </li>
        </ol>
    </li>
    <li>In the RatingsAnalyzer class write a public static method named "getTopK" an ArrayList of Ratables, an int (k),
        and a
        Comparator of Ratables as
        parameters and returns an ArrayList of Ratables. This method returns the top k ratables from the ArrayList based
        on the provided Comparator. This method
        must return the list in order such that the first element is the first ratable according to the provided
        Comparator. Ties can be broken arbitrarily
    </li>
</ol>

<p>
    While testing you top k method you should write code in your Main class that calls a method from your DataSources
    class to get an ArrayList of Ratables and call getTopK with this ArrayList.
</p>

<br/>
<hr/>
<h4>
    Objective 5: The Internet
</h4>

<p>
    So far we've been reading data from csv files that are saved on our hard drive. Our next objective to access song
    data that is hosted on the Internet through a web API and use the data in our program. This will allow us to work
    with real-time data that is constantly updating
</p>

<h5>Task</h5>

<ol>
    <li>Write a public static method in the DataSources class named "getSongsFromAPI" that takes no parameters and
        returns an
        ArrayList of Ratables. This method will access the API endpoint at the url
        "https://fury.cse.buffalo.edu/api/musicRatings/getAllSongs"
        which will return a JSON array where each element in the array is a JSON object in the format
        {"title":"No Regrets", "artist":"Aesop Rock", "ratings":[5,5,4,5], "youtubeID":"sClhmDN5Fcs"}. The method will
        return all the data given by the API in an ArrayList of Ratables
    </li>
</ol>


<br/>
<hr/>
<h4>
    Debriefing
</h4>

<p>
    Congratulations! You have written a complete project that analyzes ratings of
    songs and Amazon products. This program has the flexibility to read songs from a file, products from a file, or
    songs from a web API and generate top k lists based on their bayesian averages, number of ratings, or
    alphabetically. By this point you should see that this project can be expanded to rate more types of ratables from
    other sources or by different criteria without adding much additional code. By using object-oriented principles
    we are able to reuse significant amounts of code even if our goals change significantly. For example, we used the
    same exact code to add/store ratings, compare ratable, and generate top k lists based on any of three different
    criteria whether we were analyzing Amazon product reviews from a csv file or song ratings from a web API.
</p>


<!--Start Rhymes-->

== Rhymes

<h4>
    Background
</h4>

<p>
    Let's make a game! For this project we will develop the game pictured below. In this game the user will be given
    a reference word and can choose from 4 other words. One of the four choices will rhyme with the given word and
    the other three will not. The player's goal is to choose the rhyming word.
</p>

<img src="/static/rhymes1.png" class="img-fluid"/>
<br/><br/>

<p>
    Once the user selects one of the choices they will earn 1 point if their choice was the rhyming word or lose 1
    point if their choice did not rhyme with the given word. In either case the user will see a new set of words.
</p>

<img src="/static/rhymes2.png" class="img-fluid"/>
<br/><br/>
<p>
    For the purposes of this game we will say two words rhyme if the last syllable of each word is the same. A more
    formal
    definition is given below.
</p>

<br/>
<hr/>
<h4>
    Data
</h4>

<p>
    Download: <a href="/static/data/rhymingDictionary.txt">rhymingDictionary.txt</a><br/>
    Source: <a href="http://www.speech.cs.cmu.edu/cgi-bin/cmudict">http://www.speech.cs.cmu.edu/cgi-bin/cmudict</a>
</p>
<p>
    To determine if two words rhyme we will first need a way of finding the pronunciation of words. For this purpose we
    will use the dictionary given above where rhymingDictionary.txt is a subset of the CMU pronunciation dictionary
    that can be found at the source link. This subset of words were chosen to work well with this project and is
    suitable for playing this game (ie. Only common words and every word rhymes with at least 1 other word in the file).
    Please visit the source for documentation and the full dictionary download if you would like to use more than the
    provided words for other projects.
</p>

<br/>
<hr/>
<h4>
    Defining a Rhyme
</h4>

<p>
    The pronunciation dictionary provides the sounds for each word and each sound has a type. For the types we are only
    concerned if the sound is a vowel or not. All vowel sounds end with an integer that determines the stress given to
    that vowel and other sounds do not have this stress so a vowel can be identified by checking if a sound ends with an
    integer. We will say that two words rhyme if all the sounds from the last vowel and after are the same. Words
    will rhyme even if the last vowel sounds have different stress. By defining a rhyme in this way we effectively
    consider
    two words to rhyme if their last syllable have the same sound, ignoring stress. For example all the following words
    from the
    dictionary will be considered rhymes since the last vowel is the same and all sounds after the last vowel are the
    same:
</p>

<p>
    HALF &nbsp;HH AE1 F<br/>
    PHOTOGRAPH &nbsp;F OW1 T AH0 G R AE2 F<br/>
    STAFF &nbsp;S T AE1 F<br/>
    LAUGH &nbsp;L AE1 F<br/>
</p>
<p>
    These words also all rhyme with each other:
</p>
<p>
    THOUSAND &nbsp;TH AW1 Z AH0 N D<br/>
    DIAMOND &nbsp;D AY1 M AH0 N D<br/>
    FUND &nbsp;F AH1 N D<br/>
    AND &nbsp;AH0 N D<br/>
    SECOND &nbsp;S EH1 K AH0 N D<br/>
    ISLAND &nbsp;AY1 L AH0 N D<br/>
    LEGEND &nbsp;L EH1 JH AH0 N D<br/>
</p>

<br/>
<hr/>
<h4>
    Objective 1: GUI Layout
</h4>

<p>
    Before we start implementing the details of the game we will first setup the gui so we have a convenient way to see
    the later features we will add to the project.
</p>

<!--* Objective 1: Setup Testing-->
<!-- -Write Main-->
<!-- -setup GUI and GameModel headers so Main compiles-->
<!-- -GUI has component on the correct panels. Advise that the components should be stored in instance variables since they need to change throughout the game [can return empty JPanels]-->
<!-- -Recommend to get the GUI looking like it did in the example add x panel to NORTH, etc-->
<!-- -At the end of this objective they should see something that looks like the game, but with no text-->


<h5>Tasks</h5>

<ol>
    <li>Create a new project in Eclipse</li>
    <li>Create a new package in the src folder named "rhymes"</li>
    <li>
        In the rhymes package, create a new class named "GameModel" with a public constructor that takes a String as a
        parameter. The body of the constructor can be empty for now. We will add methods and instance variables to
        this class in later objectives
    </li>
    <li>
        In the rhymes package, create a new class named "GUI" with a public constructor that takes an instance of the
        GameModel class as a parameter. In this class write the following three methods that return JPanels. (Hint:
        Some of the components on these panels, and the GameModel instance from the constructor, will need to be
        stored in instance variables and initialized in the
        constructor to complete later objectives. Planning ahead can save you time later)
        <ol type="i">
            <li>
                A public method named "getWordPanel" that takes no parameters and returns a JPanel. This JPanel will
                contain a single JLabel. In later objectives this label will contain the word given to the player.
                (In the example images this is the NORTH panel on the JFrame)
            </li>
            <li>
                A public method named "getChoicesPanel" that takes no parameters and returns a JPanel. This JPanel will
                contain 4 JButtons with any text, for now. In later objectives these buttons will contain the choices
                provided for the player. (In the example images this is the CENTER panel on the JFrame)
            </li>
            <li>
                A public method named "getScorePanel" that takes no parameters and returns a JPanel. This JPanel will
                contain a single JLabel with the text "Score:". In later objectives this label will contain the current
                score of the player.
                (In the example images this is the SOUTH panel on the JFrame)
            </li>
        </ol>
    </li>
    <li>
        In the rhymes package, create a new class named "Main" and write a main method in this class. This class
        will be the only one with a main method or a JFrame. Do not add a JFrame anywhere else in your project. In this
        class you can test and play your game by setting up a JFrame in the same way we've been using in the class
        and adding the three GUI panels to the locations given above. You will need to create new GameModel and GUI
        instances to setup this JFrame
    </li>
</ol>


<!--/**-->
<!--* Objective 1: Setup Testing-->
<!-- -Write Main-->
<!-- -setup GUI and GameModel headers so Main compiles-->
<!-- -GUI has component on the correct panels. Advise that the components should be stored in instance variables since they need to change throughout the game [can return empty JPanels]-->
<!-- -Recommend to get the GUI looking like it did in the example add x panel to NORTH, etc-->
<!-- -At the end of this objective they should see something that looks like the game, but with no text-->


<br/>
<hr/>
<h4>
    Objective 2: Rhyming Dictionary
</h4>

<p>
    Since rhyming is a core feature of this game we will need a way to determine whether or not two words rhyme.
    For this objective we will write a method that will accomplish this by using the rhyming dictionary provided
    in the data section above.
</p>


<h5>Tasks</h5>


<ol>
    <li>
        In the rhymes package, create another package named "dictionary" and in this new package create a class named
        "RhymingDictionary" with the following
        <ol type="i">
            <li>
                A public constructor that takes a String as a parameter. This String will be interpreted as the filename
                for a rhyming dictionary in the same format as the one given in the data section of this project
                (ie. rhymingDictionary.txt). In this format each line contains the word, then two spaces, then each
                sound in that word separated by single spaces. All this data should be stored in an instance variable(s)
                so it can be used in the other methods of this class (Hint: while parsing this file you can call .split
                on each
                line with " &nbsp;" and " " as parameters instead of "," as we did while parsing csv files)
            </li>
            <li>
                A public method named "isRhyme" that takes two Strings as parameters and returns a boolean. This method
                returns true if the two input Strings rhyme according to the definition given above. It will return
                false if the words do not rhyme, or if either word is not in the dictionary. The case of the letters in
                the input words should be ignored
            </li>
        </ol>

    </li>

</ol>

<!--Objective 2: Parse Dictionary + isRhyme-->
<!-- -Create RhymingDictionary in dictionary package-->
<!-- -Write constructor that parses the file-->
<!-- -isRhyme-->

<br/>
<hr/>
<h4>
    Objective 3: Random Words
</h4>

<p>
    Now that we can determine if two words rhyme we can start writing methods that will interact with our game.
    For this objective you will write methods to get random words to give to the player and generate the 4 random
    choices.
</p>

<h5>Tasks</h5>
<ul>
    <li>
        In the RhymingDictionary class, write a public method named "randomWord" that takes no parameters and returns a
        String. This method will return a random word that is in the rhyming dictionary. You may use any approach to get
        a random word as long as each word in the dictionary has [close to] an equal probability of being returned.
        Recall from Lab 8 that one approach is to call Collections.shuffle on an ArrayList of Strings containing all the
        words in the dictionary then returning the word at index 0
    </li>
    <li>
        In the RhymingDictionary class, write a public method named "getChoices" that takes a String as a parameter and
        returns an ArrayList of Strings. The returned ArrayList will contain the 4 choices that will be given to the
        player of the game. Of the four choices, exactly 1 of them will rhyme with the reference word (the input of
        this method is the reference word. The rhyming word cannot be the reference word) and the other 3 will not
        rhyme. All these words will be randomly chosen so the user will have
        different choices even if they see the same reference word multiple times. The position of the correct choice
        must also be randomized (ie. If the correct answer is always on the left-most button the game is trivial.
        Similarly, a
        multiple choice exam where every answer is "c" can be easy). (Hint: Create two ArrayLists, one with all words
        that
        rhyme with the input and another with all words that don't rhyme with the input and call Collections.shuffle
        on both to get random choices in the way as we used with the randomWord method. Add the four words to ArrayList
        that you will return, then call Collections.shuffle on these choices before returning them)
    </li>
</ul>


<!--Objective 3: Random Words-->
<!-- -randomWord-->
<!-- -getChoices-->


<br/>
<hr/>
<h4>
    Objective 4: The Game Model
</h4>
<p>
    Your next objective is to implement the logic of the game and initialize the gui for the first round of the game.
    After this objective is complete the gui should look like the gui from the images and will have appropriate choices and a
    reference word given to the user. You have already written a lot of this functionality in the RhymingDictionary
    class which will be used to complete this objective.
</p>

<h5>Tasks</h5>

<ol>
    <li>
        Implement the existing GameModel class with the following functionality: (Note that after implementing this class
        the logic of the game is fully functional and is ready to be played if it is connected to a user interface. By
        keeping the code for the game separate from the user interface we can easily reuse this game with a different
        interface. For example, we can use this same game model as a web game by writing a web interface
        for the game)
        <ol type="i">
            <li>
                Implement the existing constructor to interpret the input String as the filename for a rhyming
                dictionary file that will be used for this instance of the game and initialize the game by setting the
                player's score to 0 and generating the first reference word and the 4 choices
            </li>
            <li>
                A public method named "makeChoice" that takes a String as a parameter and has return type void. This
                method will interpret the input as a guess made by the player and update the state of the game
                according to the rules of the game given in the background section
            </li>
            <li>
                A public method named "getScore" that takes no parameters and returns the player's current score as an
                int
            </li>
            <li>
                A public method named "getGivenWord" that takes no parameters and returns the reference word that
                is given to the player as a String
            </li>
            <li>
                A public method named "getChoices" that takes no parameters and returns the 4 choices that are given to
                the player as an ArrayList of Strings
            </li>
        </ol>
    </li>
    <li>Now connect the logic of the game to the gui that we wrote in objective 1. We will do this by implementing
        the following:
        <ol type="i">
            <li>
                When the GUI constructor is called, set the text of the 2 labels and 4 buttons to the appropriate values
                from
                the GameModel instance that is the parameter of the constructor
            </li>
            <li>
                Write a public method named "update" that takes no parameters and has return type void. This method will
                update the text of the 2 labels and 4 buttons to the appropriate values from
                the GameModel instance. This method will be called whenever the GameModel instance changes state so the
                most current information is displayed to the user
            </li>
        </ol>

    </li>
</ol>


<!--Objective 4: GameModel-->
<!-- -GameModel class-->
<!-- -GUI initialization so the first round of the game is visible in the GUI-->


<br/>
<hr/>
<h4>
    Objective 5: Game Controller
</h4>

<p>
    At this point you have all the logic needed for the game and a complete gui for the user to interact with the game,
    however we're missing a way for the model and the gui to interact with each other. We will write one final class
    that will control this interaction and connect all of our code together to complete the game (If you are interested
    in learning more about this approach to software design it is formally defined as Model-View-Controller, or
    <a href="https://en.wikipedia.org/wiki/Model–view–controller">MVC</a>)
</p>

<h5>Tasks</h5>

<ol>
    <li>
        In the rhymes package, write a new class named AnswerListener that implements the MouseListener interface.
        This class will connect the rest of our code together and instances of it will be attached to the choice buttons on
        the gui so they can react to the user. In this class implement:
        <ol type="i">
            <li>
                A public constructor that takes a JButton, a GameModel, and a GUI as parameters in that order and
                stores these in instance variables. These instances will give this controller access to both the model
                and the gui, as well as a reference to the button to which this instance is attached
            </li>
            <li>
                Change the foreground color of the button to BLUE when the mouse enters the button, BLACK when the mouse
                exits the button, WHITE when the mouse is pressed on the button, and BLUE when the mouse
                is released on the button. This color changing will make our game more responsive to the user
            </li>
            <li>
                When the mouse is released on the button, make a guess using the text on that button then update
                the gui
            </li>
        </ol>
    </li>
    <li>
        Attach a new instance of AnswerListener to each of the buttons on the gui. Run Main and verify that your game
        is fully functional
    </li>
</ol>


<br/>
<hr/>
<h4>
    Debriefing
</h4>

<p>
    You just wrote a whole game with quite a few pieces. More than that, you have a good amount of code that be
    easily reused in other coding projects for other ideas that you may have. For example, if you want to write a
    program where
    knowing how to pronounce words is important you can reuse your RhymingDictionary class and save a lot of time. You may
    want to add more methods to this class, but you won't be rewriting all the code to parse the dictionary file and
    find the sounds for a given word. Or if you want to write a program to help you write lyrics that rhyme you
    can use this class to generate a list of all words that rhyme with a given word and list of every possible
    word that you can choose from. In this case you should download the full dictionary from the reference link.
</p>

<p>
    Whether you reuse this code or not, as you progress through your career in software development you should always
    keep in mind that by separating the functionality in your program you can save a lot of time later by reusing that
    code. This also has the benefit that your code will be easier to test and maintain. For example, if we want to
    change the definition of a rhyme to require all syllables to rhyme or to require that the stress on the last vowel
    has to match we only have to make that change in the isRhyme method. One change in the code and the entire game will
    be different. We could even implement multiple definitions and let the user choose which one to use through the gui.
    Or maybe we want this game to use alliterations instead of rhyme. No problem. Just change a few lines in one
    method, and maybe rename it to isAlliteration instead of isRhyme for clarity. Maybe we want to give the user 6
    options instead of 4. Add 2 more buttons and have getChoices return 2
    more wrong answers and we're done updating (as long as you used loops whenever working with these components).
    Not only are these changes easy to make, it's also easy to find the code where these changes should be made (Compared
    to writing the entire project in one file. Or much worse, one method). By
    thinking through the design of our software we can save a significant amount of time later.
</p>
<p>Or as Dr. Hertz
    puts it: <b>"hours of coding makes up for minutes of planning"</b></p>
</p>


<!--Objective 5: AnswerListener-->
<!-- -Glue it all together and make the game work-->
<!-- -Add the listener to the buttons (this in the constructor! Mind blown)-->
<!-- -This one will be easy if they did everything else right-->


<!--== Flight Tracker-->


<!--<h4>-->
<!--Background-->
<!--</h4>-->

<!--<p>-->

<!--</p>-->

<!--<br/>-->
<!--<hr/>-->
<!--<h4>-->
<!--Objective 1:-->
<!--</h4>-->
<!--<br/>-->
<!--<p>-->

<!--</p>-->

<!--<h5>Background</h5>-->
<!--<p>-->

<!--</p>-->

<!--<h5>Tasks</h5>-->

<!--<p>-->
<!--Setup the structure for this project and write a method to...-->
<!--</p>-->

<!--<ol>-->
<!--<li>Create a new project in Eclipse</li>-->
<!--<li>Create a new package in the src folder named "flights"</li>-->
<!--<li>In the flights package, create a new class named "Main" and write a main method in this class. This class-->
<!--will be the entry point for the project and will be the only class with a main method. You should use this class-->
<!--to test your project-->
<!--</li>-->
<!--</ol>-->


<!--<br/>-->
<!--<hr/>-->
<!--<h4>-->
<!--Objective 2:-->
<!--</h4>-->

<!--<p>-->

<!--</p>-->


<!--<h5>Tasks</h5>-->

<!--<ol>-->
<!--<li>-->
<!--</li>-->

<!--</ol>-->


<!--<br/>-->
<!--<hr/>-->
<!--<h4>-->
<!--Objective 3:-->
<!--</h4>-->

<!--<p>-->

<!--</p>-->

<!--<h5>Tasks</h5>-->
<!--<ul>-->
<!--<li></li>-->
<!--</ul>-->


<!--<br/>-->
<!--<hr/>-->
<!--<h4>-->
<!--Objective 4:-->
<!--</h4>-->
<!--<p>-->

<!--</p>-->

<!--<h5>Tasks</h5>-->

<!--<ol>-->
<!--<li></li>-->
<!--<li></li>-->
<!--</ol>-->

<!--<br/>-->
<!--<hr/>-->
<!--<h4>-->
<!--Objective 5:-->
<!--</h4>-->

<!--<p>-->

<!--</p>-->

<!--<h5>Tasks</h5>-->

<!--<ol>-->
<!--<li></li>-->
<!--</ol>-->
